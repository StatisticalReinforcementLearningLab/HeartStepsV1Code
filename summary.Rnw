\documentclass{article}
\usepackage[T1]{fontenc}
\usepackage[margin=1in]{geometry}
\usepackage{microtype}
\usepackage{booktabs}
\usepackage{enumitem}
\usepackage{setspace}
\usepackage{ragged2e,array}
\usepackage{hyperref}
\usepackage[capitalize]{cleveref}
\usepackage{graphicx}
\IfFileExists{MinionPro.sty}
  {\usepackage[mathlf,italicgreek,loosequotes]{MinionPro}
   \DisableLigatures[T]{encoding={OT1,T1}}
   \usepackage[toc,enum,bib,lineno,eqno]{tabfigures}}
  {\usepackage{times}
   \let\figureversion\@gobble
   \IfFileExists{mtpro2.sty}
     {\let\Bbbk\relax\usepackage[mtphrb]{mtpro2}}
     {\usepackage{mathptmx}}}
% environment hooks
\usepackage{etoolbox}

% make smallcaps/figures searchable
\input{glyphtounicode}
\pdfgentounicode=1

% correct Acrobat distortion with opacity
\pdfpageattr{/Group <</S /Transparency /I true /CS /DeviceRGB>>}

\hypersetup{breaklinks,colorlinks,allcolors=blue,pdfpagemode=UseNone}

\BeforeBeginEnvironment{tabular}{\begin{center}\figureversion{lf,tab}}
\AfterEndEnvironment{tabular}{\end{center}}
\AtBeginEnvironment{tabular}{\small\hyphenpenalty=10000}
\AtBeginEnvironment{tikzpicture}{%
  \figureversion{lf,tab}\small\hyphenpenalty=10000}

\newcolumntype{L}[1]{>{\RaggedRight\hspace{0pt}}p{#1}}
\newcolumntype{R}[1]{>{\RaggedLeft\hspace{0pt}}p{#1}}
\setlength{\tabcolsep}{6pt}

\setlist{leftmargin=\parindent,rightmargin=\parindent}

\DeclareMathOperator{\uniform}{Uniform}

\linespread{1.15}
\raggedbottom
\allowdisplaybreaks
\columnsep=1em

% R code "chunk" format:
% <<chunk options>>= R code @
% see http://yihui.name/knitr/options/#chunk{\_}options for chunk options

\title{\bfseries HeartSteps data summary}
\author{}
\date{\vskip -2em\normalsize\today}

\begin{document}
\maketitle
\thispagestyle{empty}

<<setup, include=FALSE, cache=FALSE>>=
opts_chunk$set(fig.align="center", dev="tikz", dev.args=list(pointsize=9), cex=0.95, echo=FALSE, fig.width=6.5, fig.show="hold", par=TRUE)
knit_hooks$set(par=function(before, options, envir){
  if (before && options$fig.show!="none")
    par(mar=c(3,5,1,0)+0.5, mgp=c(2,0.5,0), oma=rep(0,4), las=1, tcl=0.25)})
@

<<data, echo=FALSE, include=FALSE>>=
source("init.R")
setwd(sys.var$mbox.data)
load("csv.RData")
load("analysis.RData")
setwd(sys.var$repo)
@

\section{Data irregularities}

\subsection{EMA and momentary decision identifiers}
\label{sec:id}

The contextID variable was intended to uniquely identify each EMA notification and link between the EMA-related tables. However the contextID in EMA{\_}Context{\_}Notified does not represent all of the identifier values encountered in the remaining tables. Moreover different contextIDs are associated with responses within the same EMA. The reason for the former issue is described in \cref{sec:context}. More investigation is needed to determine the cause of the latter problem.

The decisionID variable was intended to uniquely identify each decision point in Momentary{\_}Decision and link to the suggestion response in the Response table. However the decisionID value is sometimes re-used for subsequent decision points, and these recurrences appear in slightly different ways in Momentary{\_}Decision and Response. This particular issue is due to a race condition in which the decisionID value stored on the phone is read before being updated.

Although relatively infrequent, these problems do not arise in predictable ways and prevent systematic linkage between tables. We instead construct identifiers with userID and date-time variables, accounting for time lags due for activity recognition or user response.

\subsection{Duplication}
\label{sec:dup}

Duplicate entries arise according to various identifiers available from the data. The overall number of unanticipated duplicates is small, but prevents consistent linkage between tables. We resolve duplicates according to the rules below.

\begin{tabular}{L{0.2\textwidth}L{0.3\textwidth}L{0.4\textwidth}}
\toprule
Table & Source of duplication & Resolution \\
\midrule
EMA{\_}Context{\_}Engaged & Multiple activity recognition attempts & Discard duplicates with invalid activity recognition \\
\midrule
Structured{\_}Planning, Unstructured{\_}Planning & User revisited screen & Discard earlier or next-day duplicate plans \\
\midrule
EMA{\_}Response & User revisited screen & Discard earlier duplicate responses \\
\midrule
EMA{\_}Completed & Unknown & Due to additional issues (see \cref{sec:complete}), use table only for time zone information \\
\midrule
Momentary{\_}Decision & Time zone bugs (see \cref{sec:slot}) and other unknown reasons & Keep decisions that correctly link to Response, have a response, have the lowest time slot discrepancy or are not prefetched. \\
\bottomrule
\end{tabular}

\subsection{Inactive server-phone connection}

We cannot always find the anticipated data for each user-designated notification time slot. For example at the EMA notification time slot for a given user, we might find no corresponding records in any of the EMA-related tables. This presumably arises over periods when the user's phone is turned off or out of network coverage.
<<inactive-ema, fig.height=3>>=
with(daily, plot(NULL, xlim = c(0, max(study.day)), ylim = c(0, max(user.index)),
                 frame.plot = FALSE, xlab = "Study day", ylab = "User index"))
with(daily, segments(0, user.index, pmax(study.day), col = "grey"))
with(subset(daily, !connect),
     points(study.day, user.index, pch = 16, col = "darkgrey"))
@

<<inactive, fig.height=3>>=
with(suggest, plot(NULL, xlim = c(0, max(index)), ylim = c(0, max(user.index)),
                   frame.plot = FALSE, xlab = "Momentary decision index",
                   ylab = "User index"))
with(suggest, segments(0, user.index, pmax(index), col = "grey"))
with(subset(suggest, !connect),
     points(index, user.index, pch = 16, col = grey(0.2, alpha = 0.3)))
@

\subsection{Notifications under changing time zone}
\label{sec:slot}

Prior to November notifications were sent according to the time zone at which the phone was last restarted, irrespective of the actual time zone. From November onward, notifications are sent under the actual time zone, irrespective of the notification history. So users who travel potentially receive notifications outside their designated time slots or repeated notifications in the same time slot. 

Instances where the momentary decision took place outside the designated time slot are depicted below, where darker points coincide with larger differences between the intended and actual time slots. In comparing the decision time stamp and the time slow, we account for any discrepancies due to the time lag that arises when the decision is based on pre-fetched data.
<<slot, fig.height=3>>=
with(suggest, plot(NULL, xlim = c(0, max(index)), ylim = c(0, max(user.index)),
                   frame.plot = FALSE, xlab = "Momentary decision index",
                   ylab = "User index"))
with(subset(suggest, slot != time.stamp.slot),
     points(index, user.index, pch = 16,
            col = rev(grey.colors(4))[abs(slot - time.stamp.slot)]))
d <- sapply(unique(suggest$user),
            function(u) with(subset(suggest, user == u),
                             table(slot != time.stamp.slot)), simplify = FALSE)
d <- do.call("c", lapply(d, function(x) x[1] / sum(x)))
@
The proportion of within-slot decisions among the users has an average of $\Sexpr{round(mean(d), 2)}$ and range $\Sexpr{round(min(d), 2)}$--$\Sexpr{round(max(d), 2)}$. Because the discrepancy from the designated time slots tends to be small and infrequent, we propose simply indexing decisions as they arise; any variables representing calendar time (e.g. time of day) could be evaluated under the correct time zone.

\subsection{Randomized suggestion status}

The Momentary{\_}Decision table provides the availability (on the basis of the recognized activity and snooze status) and randomized suggestion status. However the values recorded do not agree with the administered suggestion status in the Response table. This discrepancy is likely due to a race condition in which the Momentary{\_}Decision status stored on the phone is read before being updated. So its value might represent the positive status used as a default value for the prefetch decision.

<<suggest, results="asis">>=

d <- with(suggest, table(notify & connect, is.na(response), useNA = "ifany"))
rownames(d) <- colnames(d) <- c("Don't send", "Send")
d <- rbind(cbind(c("", "Momentary{\\_}Decision", rep("", nrow(d) - 1)),
                 c("Response", rownames(d)), rbind(colnames(d), d)),
           c("", "Total", apply(d, 2, sum)))
rownames(d) <- NULL
print(xtable(d, digits = 0, align = rep("r", ncol(d) + 1)),
      floating = FALSE, booktabs = TRUE, hline.after = c(-1, 1, -1:0 + nrow(d)),
      include.rownames = FALSE, include.colnames = FALSE,
      sanitize.text.function = identity)
@

\subsection{Randomized planning status}

The EMA{\_}Context{\_}Notified table provides the randomized planning status, but the values recorded in this table often do not agree with the administered planning status in the Structured{\_}Planning and Unstructured{\_}Planning tables. This discrepancy is due to a race condition in which the EMA{\_}Context{\_}Notified planning status stored on the phone is read before being updated. So its value might represent either an initial or previous status value. 

<<plan, results="asis">>=
d <- with(daily, table(capitalize(planning.today), capitalize(planning),
                       useNA = "ifany"))
rownames(d)[nrow(d)] <- colnames(d)[ncol(d)] <- "Unknown"
d <- rbind(cbind(c("", "EMA{\\_}Context{\\_}Notified", rep("", nrow(d) - 1)),
                 c("", rownames(d)), rbind(colnames(d), d)),
           c("", "Total", apply(d, 2, sum)))
rownames(d) <- NULL
cm <- paste0("& & \\multicolumn{", ncol(d) - 2, "}{c}{",
             "Structured{\\_}Planning, Unstructured{\\_}Planning,",
             " EMA{\\_}Response}\\\\ \n", "\\cmidrule{3-", ncol(d), "}\n")
print(xtable(d, digits = 0, align = rep("r", ncol(d) + 1)),
      floating = FALSE, booktabs = TRUE, hline.after = -1:0 + nrow(d),
      include.rownames = FALSE, include.colnames = FALSE,
      add.to.row = list(pos = as.list(-1:1),
                        command = c("\\toprule\n", cm, "\\midrule\n")),
      sanitize.text.function = identity)
@

We conjecture that the issue does not affect the actual, \emph{administered} planning status recorded in Structured{\_}Planning and Unstructured{\_}Planning. However for the $\Sexpr{with(daily, sum(is.element(planning, c(NA, "disconnected"))))}$ EMAs that have no corresponding record in Structured{\_}Planning, Unstructured{\_}Planning or EMA{\_}Response, we do not know the randomized planning status. This number can be broken down into three settings:

\begin{itemize}
\item $\Sexpr{with(daily, sum(!connect))}$ cases where the user's phone had no active connection. We could consider the user unavailable for the planning intervention.
\item $\Sexpr{with(daily, sum(connect & !view & !respond))}$ cases where the user had an active connection, but probably did not view the questionnaire. We could simply regenerate the randomized planning status.
\item $\Sexpr{with(daily, sum(view & !respond))}$ cases where we know that the user engaged with the questionnaire, but did not respond. Based on the EMA engagement definition, the randomized planning status is most likely ``No planning.''
\end{itemize}

\subsection{EMA question set}

The EMA{\_}Completed table contains a variable EMA{\_}Set{\_}Today, which should provide the ordered set of EMA questions sent to the user. In \Sexpr{with(notify, sum(ema.set.today != ema.set, na.rm = TRUE))} cases, EMA{\_}Set{\_}Today does not agree with the sequence of questions that the user answered. This is due to a race condition in which the question set stored on the phone is read before being updated. To resolve this, we infer the administered question set from EMA{\_}Response; the question set for incomplete EMAs is not entirely recoverable, particularly if the user engaged with the EMA.

\subsection{Missing EMA context}
\label{sec:context}

A total of $\Sexpr{with(daily, sum(is.na(context.utime) & !is.na(ema.set.length)))}$ EMA responses have no contextual data available from notification or engagement. This was due to server-side dispensing of records for which the activity could not be recognized---a bug that was identified and patched in September.

\subsection{EMA completion status}
\label{sec:complete}

The EMA{\_}Completed table was intended to provide the EMA completion status, but it is not always in agreement with the data available in EMA{\_}Response. The reason for this is unclear, but we address the discrepancy by inferring completion status from EMA{\_}Response. Below we tabulate completion status by the number of EMA answers available for each contextID encountered in either table.

<<complete, results="asis">>=
d <- merge(aggregate(completed ~ contextid, any, data = complete),
           subset(ema, order == 1), by = "contextid", all = TRUE)
d$ema.set.length[is.na(d$ema.set.length)] <- 0
d <- with(d, table(completed, ema.set.length, useNA = "ifany"))
d <- rbind(as.numeric(colnames(d)), d)
rownames(d) <- c("Number of answers", "Incomplete", "Complete")
print(xtable(d, digits = 0),
      floating = FALSE, booktabs = TRUE, include.colnames = FALSE,
      hline.after = c(-1, 1, nrow(d)))
@

\subsection{Suggestion message tags and strings}

The activity suggestion messages were not stored with the bucket tags used for contextualization. To address this we apply all relevant tags post-hoc, using the curated list of suggestions. Note that all relevant tags are not necessarily the tags that influenced the message selection. Moreover the list gives the message strings as-displayed with non-ASCII characters. Internally HeartSteps strips ASCII characters from messages before saving them to the datastore, but this operation is not performed consistently. To enable correct linkage, we strip all message strings of escape codes, punctuation, non-ASCII characters and normalize white space.

\section{User characteristics}

The intake and exit interview data are updated less frequently than the application data. Here is a summary of the intake information available for \Sexpr{nrow(intake)} users.

<<users, results="asis">>=
d <- with(users,
          cbind("Male" = gender == "male",
                "Age under 25" = age < 25,
                "White" = ethnicity == "white/caucasian",
                "Graduate school" = edu %in% c("grad degree", "grad school"),
                "Married or common-law" = marital %in%
                              c("married", "domestic partnership"),
                "Any children" = children > 0,
                "Used fitness app" = fitapp == "yes",
                "Used activity tracker" = tracker == "yes"))
d <- cbind(apply(d, 2, sum, na.rm = TRUE),
           apply(d, 2, sum, na.rm = TRUE)
           / sum(!apply(d, 1, function(x) any(is.na(x)))) * 100)
colnames(d) <- c("Number", "Percent")
print(xtable(d, digits = c(0, 0, 1)), floating = FALSE, booktabs = TRUE)
@

\section{EMAs}

\subsection{Hecticness}

At each EMA, the user was asked ``How hectic was your day today?'' A $\Sexpr{length(ema1)}$-point scale was provided, with $\Sexpr{ema1[1]}$ labelled as ``\Sexpr{names(ema1[1])}'' and \Sexpr{length(ema1)} labelled as ``\Sexpr{names(rev(ema1)[1])}''.  Here we depict the responses over time, where darker points correspond to more hectic days. No point is plotted if no response is available, due to either non- or pending response.
<<ema1, fig.height=3>>=
with(daily, plot(study.day, user.index, pch = 16,
                 col = rev(grey.colors(length(ema1)))[hectic],
                 frame.plot = FALSE, xlab = "Study day", ylab = "User index"))
@

\subsection{Stress}

At each EMA, the user was asked ``How stressful was your day today?'' A $\Sexpr{length(ema2)}$-point scale was provided, with $\Sexpr{ema1[1]}$ labelled as ``\Sexpr{names(ema2[1])}'' and \Sexpr{rev(ema1)[1]} labelled as ``\Sexpr{names(rev(ema2)[1])}''. Here we depict the responses over time, where darker points correspond to more stressful days. No point is plotted if no response is available, due to either non- or pending response.
<<ema2, fig.height=3>>=
with(daily, plot(study.day, user.index, pch = 16,
                 col = rev(grey.colors(length(ema2)))[stressful],
                 frame.plot = FALSE, xlab = "Study day", ylab = "User index"))
@

\subsection{Typicalness for the day of the week}

At each EMA, the user was asked ``How typical was today for a X?'', where ``X'' is the current day of the week. A $\Sexpr{length(ema3)}$-point scale was provided, with $\Sexpr{ema1[1]}$ labelled as ``\Sexpr{names(ema3[1])}'' and \Sexpr{rev(ema1)[1]} labelled as ``\Sexpr{names(rev(ema3)[1])}''.  Here we depict the responses over time, where darker points correspond to more atypical days. No point is plotted if no response is available, due to either non- or pending response. 
<<ema3, fig.height=3>>=
with(daily, plot(study.day, user.index, pch = 16,
                 col = grey.colors(length(ema3))[typical],
                 frame.plot = FALSE, xlab = "Study day", ylab = "User index"))
@

\section{Daily step count}

The following plots give the daily step count for each user; the solid series corresponds to Jawbone and dotted to Google Fit. Breaks in the series indicate no step counts were recorded that day. Grey segments of the series indicate that planning was carried out the day before. The horizontal line gives the user average daily Jawbone step count; this extends up to the known or projected exit date. Vertical lines correspond to days on which no part of the EMA was completed, with the dotted line type indicated that this was due to an inactive connection at the EMA time slot.
<<dailysteps, fig.height=1.75>>=
daily$last.jbsteps <- with(daily, delay(user, study.day, jbsteps))
daily$next.jbsteps <- with(daily, delay(user, study.day, jbsteps, -1))
daily$seg.jbsteps <- with(daily, !is.na(jbsteps) & !is.na(next.jbsteps))
daily$last.gfsteps <- with(daily, delay(user, study.day, gfsteps))
daily$next.gfsteps <- with(daily, delay(user, study.day, gfsteps, -1))
daily$seg.gfsteps <- with(daily, !is.na(gfsteps) & !is.na(next.gfsteps))
daily$plan <- daily$planning %in% c("structured", "unstructured")
plot.daily.steps <- function(u) {
  d <- subset(daily, user == u)
  maxs <- max(1, d$jbsteps, d$gfsteps, na.rm = TRUE)
  maxd <- max(d$study.day)
  slwd <- 1.5
  pcol <- "darkgrey"
  plot(NULL, xlim = c(0, max(maxd, 42)), ylim = c(0, maxs),
       xlab = "", ylab = "", main = "", axes = FALSE, frame.plot = FALSE)
  mtext(paste(u), 2, line = 3)
  apply(subset(d, is.na(ema.set.length) & study.day < maxd,
               select = c(study.day, connect)), 1,
        function(x) abline(v = x[1], col = "lightgrey",
                           lty = c("dotted", "solid")[x[2] + 1]))
  meanjb <- mean(d$jbsteps, na.rm = TRUE)
  segments(0, meanjb, max(d$study.day, 42 * (d$last.date[1] > max.date)), meanjb,
           col = "lightgrey")
  with(subset(d, !plan & seg.gfsteps),
       segments(study.day, gfsteps, study.day + 1, next.gfsteps,
                lty = "dotted", lwd = slwd))
  with(subset(d, plan & seg.gfsteps),
       segments(study.day, gfsteps, study.day + 1, next.gfsteps,
                lty = "dotted", col = pcol, lwd = slwd))
  with(subset(d, !plan & seg.jbsteps),
       segments(study.day, jbsteps, study.day + 1, next.jbsteps, lwd = slwd))
  with(subset(d, plan & seg.jbsteps),
       segments(study.day, jbsteps, study.day + 1, next.jbsteps,
                col = pcol, lwd = slwd))
  at <- with(d, c(0, study.day[is.na(jbsteps) & !is.na(last.jbsteps)] - 1,
                  study.day[!is.na(jbsteps) & is.na(last.jbsteps)], maxd, 42))
  axis(1, at = sort(unique(at)))
  axis(2, at = sort(round(c(0, meanjb, maxs))))
}
invisible(sapply(unique(daily$user), plot.daily.steps))
@

\end{document}
